name: Full Stage Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target stage to deploy"
        required: true
        type: choice
        options:
          - staging
          - prod

jobs:
  deploy-stage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ap-southeast-1

      - name: Set environment
        id: env
        run: |
          echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT

      - name: Deploy Lambdas if changed / new
        run: |
          ENV=${{ steps.env.outputs.ENV }}
          LAMBDAS=("get_google_sign_in_url" "get_ebook_metadata")   # Add Lambda names as needed

          declare -A LAMBDA_RUNTIME # Define runtimes for each Lambda
          LAMBDA_RUNTIME["get_google_sign_in_url"]="3.13"
          LAMBDA_RUNTIME["get_ebook_metadata"]="3.13"

          declare -A LAMBDA_ENV
          LAMBDA_ENV["get_google_sign_in_url"]="ALLOWED_ORIGINS=${{ vars.ALLOWED_ORIGINS }},COGNITO_CLIENT_ID=${{ vars.COGNITO_CLIENT_ID }},COGNITO_DOMAIN=${{ vars.COGNITO_DOMAIN }},COGNITO_REDIRECT_URI=${{ vars.COGNITO_REDIRECT_URI }},ORIGINS=${{ vars.ORIGIN }}"

          LAMBDA_ENV["get_ebook_metadata"]="BOOK_KEY=${{ vars.BOOK_KEY }},EBOOK_BUCKET=${{ vars.EBOOK_BUCKET }},ORIGIN=${{vars.ORIGIN}},USER_POOL_ID=${{vars.USER_POOL_ID}}"


          for lambda in "${LAMBDAS[@]}"; do
            HASH_FILE=".github/.${lambda}.hash"
            if [ ! -d "$lambda" ]; then
              echo "Directory for $lambda not found, skipping"
              continue
            fi

            NEW_HASH=$(shasum -a 256 $lambda/* 2>/dev/null | shasum -a 256 | awk '{print $1}')
            OLD_HASH=$(cat $HASH_FILE 2>/dev/null || echo "")

            if [ "$NEW_HASH" != "$OLD_HASH" ]; then
              echo "Updating $lambda..."

              PYTHON_VERSION=${LAMBDA_RUNTIME[$lambda]}
              echo "Packaging $lambda with Python $PYTHON_VERSION"

              TMP_DIR=$(mktemp -d)
              cp -r $lambda/* $TMP_DIR/

              if [ -f "$TMP_DIR/requirements.txt" ]; then
                echo "Installing dependencies for $lambda using Docker"
                docker run --rm -v $PWD:/app -w /app python:$PYTHON_VERSION bash -c "
                  pip install -r $TMP_DIR/requirements.txt -t $TMP_DIR"
              fi

              cd $TMP_DIR && zip -r ../../$lambda.zip . && cd -
              rm -rf $TMP_DIR

              echo "Updating environment variables for $lambda"
              aws lambda update-function-configuration \
                --function-name $lambda \
                --environment "Variables=${LAMBDA_ENV[$lambda]}"

              # Update Lambda code only
              aws lambda update-function-code \
                --function-name $lambda \
                --zip-file fileb://$lambda.zip \
                --publish

              VERSION=$(aws lambda publish-version --function-name $lambda --query Version --output text)

              aws lambda update-alias --function-name $lambda --name $ENV --function-version $VERSION

              echo $NEW_HASH > $HASH_FILE
            else
              echo "$lambda unchanged, skipping version publish"
            fi
          done

      - name: Update API Gateway routes for environment
        run: |
          ENV=${{ steps.env.outputs.ENV }}
          REST_API_ID=1u8zyys7vb

          # Define routes and types
          declare -A ROUTES_TYPE
          ROUTES_TYPE["/ebooks"]="cors"
          ROUTES_TYPE["/google_signin_urls"]="cors"

          # Authorizers per route
          declare -A ROUTES_AUTHORIZE
          ROUTES_AUTHORIZE["/ebooks"]="teen_${ENV}_authorizer"

          DOMAIN=${{ vars.OPTIONS_CORS_DOMAIN }}

          declare -A ROUTES_ORIGIN
          ROUTES_ORIGIN["/ebooks"]=$DOMAIN
          ROUTES_ORIGIN["/pdf-url"]=$DOMAIN

          for route in "${!ROUTES_TYPE[@]}"; do
            RESOURCE_ID=<get-resource-id-for-$route>
            TYPE=${ROUTES_TYPE[$route]}
            AUTHORIZE_ID=${ROUTES_AUTHORIZE[$route]}
            ORIGIN=${ROUTES_ORIGIN[$route]}

            if [ "$TYPE" = "cors" ]; then
              echo "Updating OPTIONS CORS headers for $route"
              aws apigateway put-method-response \
                --rest-api-id $REST_API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --status-code 200 \
                --response-models '{"application/json": "Empty"}'

              aws apigateway put-integration-response \
                --rest-api-id $REST_API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --status-code 200 \
                --response-parameters "{\"method.response.header.Access-Control-Allow-Origin\":\"$ORIGIN\",\"method.response.header.Access-Control-Allow-Methods\":\"GET,OPTIONS\",\"method.response.header.Access-Control-Allow-Headers\":\"Content-Type,Authorization\"}"

            elif [ "$TYPE" = "integration" ]; then
              echo "Updating integration response only for $route"
              aws apigateway put-integration-response \
                --rest-api-id $REST_API_ID \
                --resource-id $RESOURCE_ID \
                --http-method POST \
                --status-code 200 \
                --response-parameters "{\"method.response.header.Access-Control-Allow-Origin\":\"$ORIGIN\"}"

            elif [ "$TYPE" = "lambda_options" ]; then
              echo "OPTIONS handled by Lambda for $route, ensure integration points to $ENV alias"
              aws apigateway update-integration \
                --rest-api-id $REST_API_ID \
                --resource-id $RESOURCE_ID \
                --http-method OPTIONS \
                --patch-operations op=replace,path=/uri,value="arn:aws:apigateway:<region>:lambda:path/2015-03-31/functions/arn:aws:lambda:<region>:<account-id>:function:$route:$ENV/invocations"
            fi

            if [ -n "$AUTHORIZE_ID" ]; then
              echo "Attaching authorizer for $route"
              aws apigateway update-method \
                --rest-api-id $REST_API_ID \
                --resource-id $RESOURCE_ID \
                --http-method GET \
                --patch-operations op=replace,path=/authorizationType,value=COGNITO_USER_POOLS \
                                    op=replace,path=/authorizerId,value=$AUTHORIZE_ID
            fi
          done

      - name: Redeploy API Gateway Stage
        run: |
          ENV=${{ steps.env.outputs.ENV }}
          aws apigateway create-deployment \
            --rest-api-id $REST_API_ID \
            --stage-name $ENV \
            --description "Updated all routes for $ENV"
